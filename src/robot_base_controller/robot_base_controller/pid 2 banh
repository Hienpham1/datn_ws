import rclpy
from rclpy.node import Node
from geometry_msgs.msg import Twist
from std_msgs.msg import Int16MultiArray
from std_msgs.msg import Float32MultiArray
import math
import time
from nav_msgs.msg import Odometry

class PID:
    def __init__(self, Kp, Ki, Kd):
        self.Kp = Kp
        self.Ki = Ki
        self.Kd = Kd
        self.prev_error = 0.0
        self.integral = 0.0

    def compute(self, error, dt):
        self.integral += error * dt
        derivative = (error - self.prev_error) / dt if dt > 0 else 0.0
        output = self.Kp * error + self.Ki * self.integral + self.Kd * derivative
        self.prev_error = error
        return output


class InverseKineticNode(Node):
    def __init__(self):
        super().__init__('inverse_kinetic')

        self.pid_left = PID(Kp=0.0, Ki=0.0, Kd=0.0)
        self.pid_right = PID(Kp=0.0, Ki=0.0, Kd=0.0)

        # Declare and get parameters
        self.declare_parameter('topic_velocities', 'topic_velocities')
        self.declare_parameter('cmd_vel', 'cmd_vel')
        self.declare_parameter('wheel_radius', 0.05)
        self.declare_parameter('wheels_distance', 0.305)
        self.declare_parameter('t_acceleration', 1.0)
        self.declare_parameter('t_decreasing', 0.5)
        self.declare_parameter('v_max_motor', 310)
        self.declare_parameter('pwm_max', 255)

        self.topic_velocities = self.get_parameter('topic_velocities').get_parameter_value().string_value
        self.cmd_vel = self.get_parameter('cmd_vel').get_parameter_value().string_value
        self.wheel_radius = self.get_parameter('wheel_radius').get_parameter_value().double_value
        self.wheels_distance = self.get_parameter('wheels_distance').get_parameter_value().double_value
        self.t_acceleration = self.get_parameter('t_acceleration').get_parameter_value().double_value
        self.t_decreasing = self.get_parameter('t_decreasing').get_parameter_value().double_value
        self.v_max_motor = self.get_parameter('v_max_motor').get_parameter_value().integer_value
        self.pwm_max = self.get_parameter('pwm_max').get_parameter_value().integer_value

        # Initialize variables
        self.true_linear_vel = 0.0
        self.realtime_t = 0.0
        self.up_cnt = 0
        self.down_cnt = 0
        self.left_wheel_velocity = 0
        self.right_wheel_velocity = 0   
        self.current_left = 0.0
        self.current_right = 0.0
        self.desired_left = 0.0
        self.desired_right = 0.0
        self.prev_time = time.time()

        # Publisher and Subscriber
        self.pub_v = self.create_publisher(Int16MultiArray, self.topic_velocities, 10)
        self.pub_desired_velo = self.create_publisher(Float32MultiArray, 'desired_velo', 10)
        self.pub_current_velo = self.create_publisher(Float32MultiArray, 'current_velo', 10)

        self.sub = self.create_subscription(Twist, self.cmd_vel, self.velocities_callback, 10)
        self.sub_odom = self.create_subscription(Odometry, '/odom_encoder', self.odom_callback, 10)
        self.sub_pid_left = self.create_subscription(Float32MultiArray, '/pid_params_left', self.update_pid_left, 10)
        self.sub_pid_right = self.create_subscription(Float32MultiArray, '/pid_params_right', self.update_pid_right, 10)


    def update_pid_left(self, msg):
        kp, ki, kd = msg.data
        self.pid_linear.Kp = kp
        self.pid_linear.Ki = ki
        self.pid_linear.Kd = kd
        self.get_logger().info(f"Updated left PID: Kp={kp}, Ki={ki}, Kd={kd}")

    def update_pid_right(self, msg):
        kp, ki, kd = msg.data
        self.pid_angular.Kp = kp
        self.pid_angular.Ki = ki
        self.pid_angular.Kd = kd
        self.get_logger().info(f"Updated right PID: Kp={kp}, Ki={ki}, Kd={kd}")


    def odom_callback(self, msg):
        current_linear_vel = msg.twist.twist.linear.x
        current_angular_vel = msg.twist.twist.angular.z
        self.current_left = (1.0 / (2.0 * self.wheel_radius)) * (2.0 * current_linear_vel - self.wheels_distance * current_angular_vel)
        self.current_right = (1.0 / (2.0 * self.wheel_radius)) * (2.0 * current_linear_vel + self.wheels_distance * current_angular_vel)

        # Publish current velocities
        current_msg = Float32MultiArray()
        current_msg.data = [self.current_left, self.current_right]
        self.pub_current_velo.publish(current_msg)

    def convert_pwm(self, wheel_vel_rads):
        # Chuyển từ rad/s sang RPM
        wheel_vel_rpm = wheel_vel_rads * 9.5493
        # Chuyển từ RPM sang PWM
        pwm = (wheel_vel_rpm / self.v_max_motor) * self.pwm_max
        return int(pwm)

    def IK(self, linear_vel, angular_vel):
        # Tính toán tốc độ mong muốn cho từng bánh (rad/s)
        self.desired_left = (1.0 / (2.0 * self.wheel_radius)) * (2.0 * linear_vel - self.wheels_distance * angular_vel)
        self.desired_right = (1.0 / (2.0 * self.wheel_radius)) * (2.0 * linear_vel + self.wheels_distance * angular_vel)

        # Publish desired velocities
        desired_msg = Float32MultiArray()
        desired_msg.data = [self.desired_left, self.desired_right]
        self.pub_desired_velo.publish(desired_msg)
        # Chuyển đổi sang PWM
        self.left_wheel_velocity = self.convert_pwm(self.desired_left)
        self.right_wheel_velocity = self.convert_pwm(self.desired_right)

        self.get_logger().info(f"Desired velocities - left: {self.desired_left:.2f} rad/s, right: {self.desired_right:.2f} rad/s")
        
    def velocity_handling(self):
        msg = Int16MultiArray()
        msg.data = [-self.left_wheel_velocity, self.right_wheel_velocity]
        self.pub_v.publish(msg)

    def decreasing_acceleration(self, linear_vel):
        current_time = time.time()
        dt = current_time - self.prev_time

        if self.true_linear_vel != linear_vel and linear_vel != 0:
            self.down_cnt = 0
            if self.up_cnt < 2:
                self.realtime_t = 0
                self.acc = linear_vel / self.t_acceleration
                self.up_cnt += 1
            if self.up_cnt > 1:
                self.realtime_t += dt
            if self.realtime_t > self.t_acceleration:
                self.realtime_t = self.t_acceleration

            self.true_linear_vel = self.acc * self.realtime_t
            self.prev_time = current_time

        elif self.true_linear_vel != linear_vel and linear_vel == 0:
            self.up_cnt = 0
            if self.down_cnt < 2:
                self.realtime_t = 0
                self.speed_decreasing_const = self.true_linear_vel / self.t_decreasing
                self.down_cnt += 1
            if self.down_cnt > 1:
                self.realtime_t += dt
            if self.realtime_t > self.t_decreasing:
                self.realtime_t = self.t_decreasing
                self.true_linear_vel = 0
            else:
                self.true_linear_vel = self.speed_decreasing_const * self.t_decreasing - (self.speed_decreasing_const * self.realtime_t)
            self.prev_time = current_time

        else:
            self.realtime_t = 0
            self.up_cnt = 0
            self.down_cnt = 0
    
    def control(self, desired_linear, desired_angular):
        dt = time.time() - self.prev_time
        self.prev_time = time.time()

        #tinh toc do mong muon
        self.IK(desired_linear, desired_angular)

        #tinh sai so
        error_left = self.desired_left - self.current_left
        error_right = self.desired_right - self.current_right
        
        #compute gia tri voi pid
        corrected_left = self.pid_left.compute(error_left, dt)
        corrected_right = self.pid_right.compute(error_right, dt)

        # gioi han van toc 2 xe
        corrected_left = max(min(corrected_left, 10), -10)
        corrected_right = max(min(corrected_right, 10), -10)

        # doi qua pwm
        self.left_wheel_velocity = self.convert_pwm(self.desired_left + corrected_left)
        self.right_wheel_velocity = self.convert_pwm(self.desired_right + corrected_right)
        self.get_logger().info(f"Corrected - left: {corrected_left:.2f}, right: {corrected_right:.2f}")

        # gui pwm   
        self.velocity_handling()

    def velocities_callback(self, msg):
        self.get_logger().info(f"Received velocities: linear={msg.linear.x}, angular={msg.angular.z}")
        self.control(msg.linear.x, msg.angular.z)

def main(args=None):
    rclpy.init(args=args)
    node = InverseKineticNode()
    rclpy.spin(node)
    node.destroy_node()
    rclpy.shutdown()


if __name__ == '__main__':
    main()
